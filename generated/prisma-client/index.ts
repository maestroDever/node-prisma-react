// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  candidate: (where?: CandidateWhereInput) => Promise<boolean>;
  candidatePosition: (where?: CandidatePositionWhereInput) => Promise<boolean>;
  poll: (where?: PollWhereInput) => Promise<boolean>;
  position: (where?: PositionWhereInput) => Promise<boolean>;
  qualification: (where?: QualificationWhereInput) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userPositionLike: (where?: UserPositionLikeWhereInput) => Promise<boolean>;
  userQualificationLike: (
    where?: UserQualificationLikeWhereInput
  ) => Promise<boolean>;
  userVote: (where?: UserVoteWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  candidate: (where: CandidateWhereUniqueInput) => CandidateNullablePromise;
  candidates: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Candidate>;
  candidatesConnection: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CandidateConnectionPromise;
  candidatePosition: (
    where: CandidatePositionWhereUniqueInput
  ) => CandidatePositionNullablePromise;
  candidatePositions: (args?: {
    where?: CandidatePositionWhereInput;
    orderBy?: CandidatePositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CandidatePosition>;
  candidatePositionsConnection: (args?: {
    where?: CandidatePositionWhereInput;
    orderBy?: CandidatePositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CandidatePositionConnectionPromise;
  poll: (where: PollWhereUniqueInput) => PollNullablePromise;
  polls: (args?: {
    where?: PollWhereInput;
    orderBy?: PollOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Poll>;
  pollsConnection: (args?: {
    where?: PollWhereInput;
    orderBy?: PollOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PollConnectionPromise;
  position: (where: PositionWhereUniqueInput) => PositionNullablePromise;
  positions: (args?: {
    where?: PositionWhereInput;
    orderBy?: PositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Position>;
  positionsConnection: (args?: {
    where?: PositionWhereInput;
    orderBy?: PositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PositionConnectionPromise;
  qualification: (
    where: QualificationWhereUniqueInput
  ) => QualificationNullablePromise;
  qualifications: (args?: {
    where?: QualificationWhereInput;
    orderBy?: QualificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Qualification>;
  qualificationsConnection: (args?: {
    where?: QualificationWhereInput;
    orderBy?: QualificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QualificationConnectionPromise;
  topic: (where: TopicWhereUniqueInput) => TopicNullablePromise;
  topics: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Topic>;
  topicsConnection: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TopicConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userPositionLike: (
    where: UserPositionLikeWhereUniqueInput
  ) => UserPositionLikeNullablePromise;
  userPositionLikes: (args?: {
    where?: UserPositionLikeWhereInput;
    orderBy?: UserPositionLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserPositionLike>;
  userPositionLikesConnection: (args?: {
    where?: UserPositionLikeWhereInput;
    orderBy?: UserPositionLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserPositionLikeConnectionPromise;
  userQualificationLike: (
    where: UserQualificationLikeWhereUniqueInput
  ) => UserQualificationLikeNullablePromise;
  userQualificationLikes: (args?: {
    where?: UserQualificationLikeWhereInput;
    orderBy?: UserQualificationLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserQualificationLike>;
  userQualificationLikesConnection: (args?: {
    where?: UserQualificationLikeWhereInput;
    orderBy?: UserQualificationLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserQualificationLikeConnectionPromise;
  userVote: (where: UserVoteWhereUniqueInput) => UserVoteNullablePromise;
  userVotes: (args?: {
    where?: UserVoteWhereInput;
    orderBy?: UserVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserVote>;
  userVotesConnection: (args?: {
    where?: UserVoteWhereInput;
    orderBy?: UserVoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserVoteConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCandidate: (data: CandidateCreateInput) => CandidatePromise;
  updateCandidate: (args: {
    data: CandidateUpdateInput;
    where: CandidateWhereUniqueInput;
  }) => CandidatePromise;
  updateManyCandidates: (args: {
    data: CandidateUpdateManyMutationInput;
    where?: CandidateWhereInput;
  }) => BatchPayloadPromise;
  upsertCandidate: (args: {
    where: CandidateWhereUniqueInput;
    create: CandidateCreateInput;
    update: CandidateUpdateInput;
  }) => CandidatePromise;
  deleteCandidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  deleteManyCandidates: (where?: CandidateWhereInput) => BatchPayloadPromise;
  createCandidatePosition: (
    data: CandidatePositionCreateInput
  ) => CandidatePositionPromise;
  updateCandidatePosition: (args: {
    data: CandidatePositionUpdateInput;
    where: CandidatePositionWhereUniqueInput;
  }) => CandidatePositionPromise;
  updateManyCandidatePositions: (args: {
    data: CandidatePositionUpdateManyMutationInput;
    where?: CandidatePositionWhereInput;
  }) => BatchPayloadPromise;
  upsertCandidatePosition: (args: {
    where: CandidatePositionWhereUniqueInput;
    create: CandidatePositionCreateInput;
    update: CandidatePositionUpdateInput;
  }) => CandidatePositionPromise;
  deleteCandidatePosition: (
    where: CandidatePositionWhereUniqueInput
  ) => CandidatePositionPromise;
  deleteManyCandidatePositions: (
    where?: CandidatePositionWhereInput
  ) => BatchPayloadPromise;
  createPoll: (data: PollCreateInput) => PollPromise;
  updatePoll: (args: {
    data: PollUpdateInput;
    where: PollWhereUniqueInput;
  }) => PollPromise;
  updateManyPolls: (args: {
    data: PollUpdateManyMutationInput;
    where?: PollWhereInput;
  }) => BatchPayloadPromise;
  upsertPoll: (args: {
    where: PollWhereUniqueInput;
    create: PollCreateInput;
    update: PollUpdateInput;
  }) => PollPromise;
  deletePoll: (where: PollWhereUniqueInput) => PollPromise;
  deleteManyPolls: (where?: PollWhereInput) => BatchPayloadPromise;
  createPosition: (data: PositionCreateInput) => PositionPromise;
  updatePosition: (args: {
    data: PositionUpdateInput;
    where: PositionWhereUniqueInput;
  }) => PositionPromise;
  updateManyPositions: (args: {
    data: PositionUpdateManyMutationInput;
    where?: PositionWhereInput;
  }) => BatchPayloadPromise;
  upsertPosition: (args: {
    where: PositionWhereUniqueInput;
    create: PositionCreateInput;
    update: PositionUpdateInput;
  }) => PositionPromise;
  deletePosition: (where: PositionWhereUniqueInput) => PositionPromise;
  deleteManyPositions: (where?: PositionWhereInput) => BatchPayloadPromise;
  createQualification: (data: QualificationCreateInput) => QualificationPromise;
  updateQualification: (args: {
    data: QualificationUpdateInput;
    where: QualificationWhereUniqueInput;
  }) => QualificationPromise;
  updateManyQualifications: (args: {
    data: QualificationUpdateManyMutationInput;
    where?: QualificationWhereInput;
  }) => BatchPayloadPromise;
  upsertQualification: (args: {
    where: QualificationWhereUniqueInput;
    create: QualificationCreateInput;
    update: QualificationUpdateInput;
  }) => QualificationPromise;
  deleteQualification: (
    where: QualificationWhereUniqueInput
  ) => QualificationPromise;
  deleteManyQualifications: (
    where?: QualificationWhereInput
  ) => BatchPayloadPromise;
  createTopic: (data: TopicCreateInput) => TopicPromise;
  updateTopic: (args: {
    data: TopicUpdateInput;
    where: TopicWhereUniqueInput;
  }) => TopicPromise;
  updateManyTopics: (args: {
    data: TopicUpdateManyMutationInput;
    where?: TopicWhereInput;
  }) => BatchPayloadPromise;
  upsertTopic: (args: {
    where: TopicWhereUniqueInput;
    create: TopicCreateInput;
    update: TopicUpdateInput;
  }) => TopicPromise;
  deleteTopic: (where: TopicWhereUniqueInput) => TopicPromise;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserPositionLike: (
    data: UserPositionLikeCreateInput
  ) => UserPositionLikePromise;
  updateUserPositionLike: (args: {
    data: UserPositionLikeUpdateInput;
    where: UserPositionLikeWhereUniqueInput;
  }) => UserPositionLikePromise;
  updateManyUserPositionLikes: (args: {
    data: UserPositionLikeUpdateManyMutationInput;
    where?: UserPositionLikeWhereInput;
  }) => BatchPayloadPromise;
  upsertUserPositionLike: (args: {
    where: UserPositionLikeWhereUniqueInput;
    create: UserPositionLikeCreateInput;
    update: UserPositionLikeUpdateInput;
  }) => UserPositionLikePromise;
  deleteUserPositionLike: (
    where: UserPositionLikeWhereUniqueInput
  ) => UserPositionLikePromise;
  deleteManyUserPositionLikes: (
    where?: UserPositionLikeWhereInput
  ) => BatchPayloadPromise;
  createUserQualificationLike: (
    data: UserQualificationLikeCreateInput
  ) => UserQualificationLikePromise;
  updateUserQualificationLike: (args: {
    data: UserQualificationLikeUpdateInput;
    where: UserQualificationLikeWhereUniqueInput;
  }) => UserQualificationLikePromise;
  updateManyUserQualificationLikes: (args: {
    data: UserQualificationLikeUpdateManyMutationInput;
    where?: UserQualificationLikeWhereInput;
  }) => BatchPayloadPromise;
  upsertUserQualificationLike: (args: {
    where: UserQualificationLikeWhereUniqueInput;
    create: UserQualificationLikeCreateInput;
    update: UserQualificationLikeUpdateInput;
  }) => UserQualificationLikePromise;
  deleteUserQualificationLike: (
    where: UserQualificationLikeWhereUniqueInput
  ) => UserQualificationLikePromise;
  deleteManyUserQualificationLikes: (
    where?: UserQualificationLikeWhereInput
  ) => BatchPayloadPromise;
  createUserVote: (data: UserVoteCreateInput) => UserVotePromise;
  updateUserVote: (args: {
    data: UserVoteUpdateInput;
    where: UserVoteWhereUniqueInput;
  }) => UserVotePromise;
  updateManyUserVotes: (args: {
    data: UserVoteUpdateManyMutationInput;
    where?: UserVoteWhereInput;
  }) => BatchPayloadPromise;
  upsertUserVote: (args: {
    where: UserVoteWhereUniqueInput;
    create: UserVoteCreateInput;
    update: UserVoteUpdateInput;
  }) => UserVotePromise;
  deleteUserVote: (where: UserVoteWhereUniqueInput) => UserVotePromise;
  deleteManyUserVotes: (where?: UserVoteWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  candidate: (
    where?: CandidateSubscriptionWhereInput
  ) => CandidateSubscriptionPayloadSubscription;
  candidatePosition: (
    where?: CandidatePositionSubscriptionWhereInput
  ) => CandidatePositionSubscriptionPayloadSubscription;
  poll: (
    where?: PollSubscriptionWhereInput
  ) => PollSubscriptionPayloadSubscription;
  position: (
    where?: PositionSubscriptionWhereInput
  ) => PositionSubscriptionPayloadSubscription;
  qualification: (
    where?: QualificationSubscriptionWhereInput
  ) => QualificationSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userPositionLike: (
    where?: UserPositionLikeSubscriptionWhereInput
  ) => UserPositionLikeSubscriptionPayloadSubscription;
  userQualificationLike: (
    where?: UserQualificationLikeSubscriptionWhereInput
  ) => UserQualificationLikeSubscriptionPayloadSubscription;
  userVote: (
    where?: UserVoteSubscriptionWhereInput
  ) => UserVoteSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC";

export type CandidatePositionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "positionId_ASC"
  | "positionId_DESC"
  | "candidateId_ASC"
  | "candidateId_DESC"
  | "time_ASC"
  | "time_DESC"
  | "link_ASC"
  | "link_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "latest_ASC"
  | "latest_DESC";

export type CategoryType =
  | "ABORTION"
  | "ACTIVISM"
  | "AWARDS"
  | "AWARDS_FOR_MILITARY_SERVICE"
  | "BANKING"
  | "BIOGRAPHICAL"
  | "BIPARTISAMSHIP"
  | "BUDGET"
  | "CAMPAIGN"
  | "CIVIL_RIGHTS"
  | "CONSTITUENT_SERVICES"
  | "CRIME"
  | "DEFENSE"
  | "DRUG_POLICY"
  | "ECONOMIC_INEQUALITY"
  | "ECONOMY"
  | "EDUCATION"
  | "ENVIRONMENT"
  | "EXECUTIVE_LEADERSHIP"
  | "FOREIGN_POLICY"
  | "GAFFES"
  | "GENDER"
  | "GUN_RIGHTS_CONTROL"
  | "HEALTH_CARE"
  | "IMMIGRATION"
  | "INFRASTRUCTURE"
  | "INTELLECTUAL_ABILITY"
  | "LEGISLATIVE"
  | "MILITARY_SERVICE"
  | "POLICING"
  | "POLITICAL_STRATEGY"
  | "SCANDAL"
  | "TBD"
  | "URBAN_DEVELOPMENT";

export type UserQualificationLikeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "qualificationId_ASC"
  | "qualificationId_DESC"
  | "like_ASC"
  | "like_DESC"
  | "time_ASC"
  | "time_DESC"
  | "latest_ASC"
  | "latest_DESC";

export type QualificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "summary_ASC"
  | "summary_DESC"
  | "detail_ASC"
  | "detail_DESC"
  | "years_ASC"
  | "years_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "candidateId_ASC"
  | "candidateId_DESC"
  | "like_type_ASC"
  | "like_type_DESC";

export type UserPositionLikeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "candidateId_ASC"
  | "candidateId_DESC"
  | "positionId_ASC"
  | "positionId_DESC"
  | "like_ASC"
  | "like_DESC"
  | "time_ASC"
  | "time_DESC"
  | "latest_ASC"
  | "latest_DESC";

export type PositionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "summary_ASC"
  | "summary_DESC"
  | "topicId_ASC"
  | "topicId_DESC"
  | "detail_ASC"
  | "detail_DESC"
  | "like_type_ASC"
  | "like_type_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "role_ASC"
  | "role_DESC";

export type PollType = "PRIMARY" | "HEADTOHEAD";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PollOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "date_ASC"
  | "date_DESC"
  | "candidateId_ASC"
  | "candidateId_DESC"
  | "poll_type_ASC"
  | "poll_type_DESC"
  | "error_margin_ASC"
  | "error_margin_DESC"
  | "link_to_poll_ASC"
  | "link_to_poll_DESC";

export type LikeType = "LIKE" | "DISLIKE" | "UNSPECIFIED";

export type CandidateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "photo_ASC"
  | "photo_DESC"
  | "party_ASC"
  | "party_DESC"
  | "state_ASC"
  | "state_DESC"
  | "current_office_ASC"
  | "current_office_DESC"
  | "age_ASC"
  | "age_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "latest_poll_ASC"
  | "latest_poll_DESC"
  | "latest_odds_ASC"
  | "latest_odds_DESC"
  | "prevote_score_ASC"
  | "prevote_score_DESC"
  | "bio_summary_ASC"
  | "bio_summary_DESC"
  | "vote_type_ASC"
  | "vote_type_DESC";

export type VoteType = "TOP" | "FAVORITE" | "COMPROMISE" | "VETO" | "UNKNOWNS";

export type Gender = "MALE" | "FEMALE";

export type UserVoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "candidateId_ASC"
  | "candidateId_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "vote_type_ASC"
  | "vote_type_DESC"
  | "time_ASC"
  | "time_DESC"
  | "latest_ASC"
  | "latest_DESC";

export type QualificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserVoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  candidateId?: Maybe<String>;
  candidateId_not?: Maybe<String>;
  candidateId_in?: Maybe<String[] | String>;
  candidateId_not_in?: Maybe<String[] | String>;
  candidateId_lt?: Maybe<String>;
  candidateId_lte?: Maybe<String>;
  candidateId_gt?: Maybe<String>;
  candidateId_gte?: Maybe<String>;
  candidateId_contains?: Maybe<String>;
  candidateId_not_contains?: Maybe<String>;
  candidateId_starts_with?: Maybe<String>;
  candidateId_not_starts_with?: Maybe<String>;
  candidateId_ends_with?: Maybe<String>;
  candidateId_not_ends_with?: Maybe<String>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  vote_type?: Maybe<VoteType>;
  vote_type_not?: Maybe<VoteType>;
  vote_type_in?: Maybe<VoteType[] | VoteType>;
  vote_type_not_in?: Maybe<VoteType[] | VoteType>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  latest?: Maybe<Boolean>;
  latest_not?: Maybe<Boolean>;
  AND?: Maybe<UserVoteWhereInput[] | UserVoteWhereInput>;
  OR?: Maybe<UserVoteWhereInput[] | UserVoteWhereInput>;
  NOT?: Maybe<UserVoteWhereInput[] | UserVoteWhereInput>;
}

export interface QualificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QualificationWhereInput>;
  AND?: Maybe<
    QualificationSubscriptionWhereInput[] | QualificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    QualificationSubscriptionWhereInput[] | QualificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QualificationSubscriptionWhereInput[] | QualificationSubscriptionWhereInput
  >;
}

export type CandidateWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TopicWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<CategoryType>;
  category_not?: Maybe<CategoryType>;
  category_in?: Maybe<CategoryType[] | CategoryType>;
  category_not_in?: Maybe<CategoryType[] | CategoryType>;
  AND?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  OR?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  NOT?: Maybe<TopicWhereInput[] | TopicWhereInput>;
}

export interface CandidatePositionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  positionId?: Maybe<String>;
  positionId_not?: Maybe<String>;
  positionId_in?: Maybe<String[] | String>;
  positionId_not_in?: Maybe<String[] | String>;
  positionId_lt?: Maybe<String>;
  positionId_lte?: Maybe<String>;
  positionId_gt?: Maybe<String>;
  positionId_gte?: Maybe<String>;
  positionId_contains?: Maybe<String>;
  positionId_not_contains?: Maybe<String>;
  positionId_starts_with?: Maybe<String>;
  positionId_not_starts_with?: Maybe<String>;
  positionId_ends_with?: Maybe<String>;
  positionId_not_ends_with?: Maybe<String>;
  candidateId?: Maybe<String>;
  candidateId_not?: Maybe<String>;
  candidateId_in?: Maybe<String[] | String>;
  candidateId_not_in?: Maybe<String[] | String>;
  candidateId_lt?: Maybe<String>;
  candidateId_lte?: Maybe<String>;
  candidateId_gt?: Maybe<String>;
  candidateId_gte?: Maybe<String>;
  candidateId_contains?: Maybe<String>;
  candidateId_not_contains?: Maybe<String>;
  candidateId_starts_with?: Maybe<String>;
  candidateId_not_starts_with?: Maybe<String>;
  candidateId_ends_with?: Maybe<String>;
  candidateId_not_ends_with?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  latest?: Maybe<Boolean>;
  latest_not?: Maybe<Boolean>;
  AND?: Maybe<CandidatePositionWhereInput[] | CandidatePositionWhereInput>;
  OR?: Maybe<CandidatePositionWhereInput[] | CandidatePositionWhereInput>;
  NOT?: Maybe<CandidatePositionWhereInput[] | CandidatePositionWhereInput>;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TopicWhereInput>;
  AND?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  OR?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  NOT?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
}

export interface UserVoteUpdateInput {
  candidateId?: Maybe<String>;
  userId?: Maybe<String>;
  vote_type?: Maybe<VoteType>;
  latest?: Maybe<Boolean>;
}

export interface QualificationUpdateInput {
  name?: Maybe<String>;
  summary?: Maybe<String>;
  detail?: Maybe<String>;
  years?: Maybe<Int>;
  rank?: Maybe<Int>;
  candidateId?: Maybe<String>;
  like_type?: Maybe<LikeType>;
}

export type PollWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QualificationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  summary?: Maybe<String>;
  detail?: Maybe<String>;
  years: Int;
  rank?: Maybe<Int>;
  candidateId?: Maybe<String>;
  like_type?: Maybe<LikeType>;
}

export interface CandidateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CandidateWhereInput>;
  AND?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  OR?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
}

export interface PositionUpdateManyMutationInput {
  name?: Maybe<String>;
  summary?: Maybe<String>;
  topicId?: Maybe<String>;
  detail?: Maybe<String>;
  like_type?: Maybe<LikeType>;
}

export type CandidatePositionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface UserQualificationLikeCreateInput {
  id?: Maybe<ID_Input>;
  userId: String;
  qualificationId: String;
  like?: Maybe<LikeType>;
  latest?: Maybe<Boolean>;
}

export interface PositionUpdateInput {
  name?: Maybe<String>;
  summary?: Maybe<String>;
  topicId?: Maybe<String>;
  detail?: Maybe<String>;
  like_type?: Maybe<LikeType>;
}

export type PositionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  role?: Maybe<Int>;
  role_not?: Maybe<Int>;
  role_in?: Maybe<Int[] | Int>;
  role_not_in?: Maybe<Int[] | Int>;
  role_lt?: Maybe<Int>;
  role_lte?: Maybe<Int>;
  role_gt?: Maybe<Int>;
  role_gte?: Maybe<Int>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CandidatePositionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CandidatePositionWhereInput>;
  AND?: Maybe<
    | CandidatePositionSubscriptionWhereInput[]
    | CandidatePositionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CandidatePositionSubscriptionWhereInput[]
    | CandidatePositionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CandidatePositionSubscriptionWhereInput[]
    | CandidatePositionSubscriptionWhereInput
  >;
}

export interface CandidateWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  photo?: Maybe<String>;
  photo_not?: Maybe<String>;
  photo_in?: Maybe<String[] | String>;
  photo_not_in?: Maybe<String[] | String>;
  photo_lt?: Maybe<String>;
  photo_lte?: Maybe<String>;
  photo_gt?: Maybe<String>;
  photo_gte?: Maybe<String>;
  photo_contains?: Maybe<String>;
  photo_not_contains?: Maybe<String>;
  photo_starts_with?: Maybe<String>;
  photo_not_starts_with?: Maybe<String>;
  photo_ends_with?: Maybe<String>;
  photo_not_ends_with?: Maybe<String>;
  party?: Maybe<String>;
  party_not?: Maybe<String>;
  party_in?: Maybe<String[] | String>;
  party_not_in?: Maybe<String[] | String>;
  party_lt?: Maybe<String>;
  party_lte?: Maybe<String>;
  party_gt?: Maybe<String>;
  party_gte?: Maybe<String>;
  party_contains?: Maybe<String>;
  party_not_contains?: Maybe<String>;
  party_starts_with?: Maybe<String>;
  party_not_starts_with?: Maybe<String>;
  party_ends_with?: Maybe<String>;
  party_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  current_office?: Maybe<String>;
  current_office_not?: Maybe<String>;
  current_office_in?: Maybe<String[] | String>;
  current_office_not_in?: Maybe<String[] | String>;
  current_office_lt?: Maybe<String>;
  current_office_lte?: Maybe<String>;
  current_office_gt?: Maybe<String>;
  current_office_gte?: Maybe<String>;
  current_office_contains?: Maybe<String>;
  current_office_not_contains?: Maybe<String>;
  current_office_starts_with?: Maybe<String>;
  current_office_not_starts_with?: Maybe<String>;
  current_office_ends_with?: Maybe<String>;
  current_office_not_ends_with?: Maybe<String>;
  age?: Maybe<Int>;
  age_not?: Maybe<Int>;
  age_in?: Maybe<Int[] | Int>;
  age_not_in?: Maybe<Int[] | Int>;
  age_lt?: Maybe<Int>;
  age_lte?: Maybe<Int>;
  age_gt?: Maybe<Int>;
  age_gte?: Maybe<Int>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  latest_poll?: Maybe<Float>;
  latest_poll_not?: Maybe<Float>;
  latest_poll_in?: Maybe<Float[] | Float>;
  latest_poll_not_in?: Maybe<Float[] | Float>;
  latest_poll_lt?: Maybe<Float>;
  latest_poll_lte?: Maybe<Float>;
  latest_poll_gt?: Maybe<Float>;
  latest_poll_gte?: Maybe<Float>;
  latest_odds?: Maybe<Float>;
  latest_odds_not?: Maybe<Float>;
  latest_odds_in?: Maybe<Float[] | Float>;
  latest_odds_not_in?: Maybe<Float[] | Float>;
  latest_odds_lt?: Maybe<Float>;
  latest_odds_lte?: Maybe<Float>;
  latest_odds_gt?: Maybe<Float>;
  latest_odds_gte?: Maybe<Float>;
  prevote_score?: Maybe<Float>;
  prevote_score_not?: Maybe<Float>;
  prevote_score_in?: Maybe<Float[] | Float>;
  prevote_score_not_in?: Maybe<Float[] | Float>;
  prevote_score_lt?: Maybe<Float>;
  prevote_score_lte?: Maybe<Float>;
  prevote_score_gt?: Maybe<Float>;
  prevote_score_gte?: Maybe<Float>;
  bio_summary?: Maybe<String>;
  bio_summary_not?: Maybe<String>;
  bio_summary_in?: Maybe<String[] | String>;
  bio_summary_not_in?: Maybe<String[] | String>;
  bio_summary_lt?: Maybe<String>;
  bio_summary_lte?: Maybe<String>;
  bio_summary_gt?: Maybe<String>;
  bio_summary_gte?: Maybe<String>;
  bio_summary_contains?: Maybe<String>;
  bio_summary_not_contains?: Maybe<String>;
  bio_summary_starts_with?: Maybe<String>;
  bio_summary_not_starts_with?: Maybe<String>;
  bio_summary_ends_with?: Maybe<String>;
  bio_summary_not_ends_with?: Maybe<String>;
  vote_type?: Maybe<VoteType>;
  vote_type_not?: Maybe<VoteType>;
  vote_type_in?: Maybe<VoteType[] | VoteType>;
  vote_type_not_in?: Maybe<VoteType[] | VoteType>;
  AND?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  OR?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  NOT?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
}

export interface PollSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PollWhereInput>;
  AND?: Maybe<PollSubscriptionWhereInput[] | PollSubscriptionWhereInput>;
  OR?: Maybe<PollSubscriptionWhereInput[] | PollSubscriptionWhereInput>;
  NOT?: Maybe<PollSubscriptionWhereInput[] | PollSubscriptionWhereInput>;
}

export interface PositionCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  summary?: Maybe<String>;
  topicId?: Maybe<String>;
  detail?: Maybe<String>;
  like_type?: Maybe<LikeType>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  gender?: Maybe<Gender>;
  role?: Maybe<Int>;
}

export interface PollUpdateManyMutationInput {
  userId?: Maybe<String>;
  candidateId?: Maybe<String>;
  poll_type?: Maybe<PollType>;
  error_margin?: Maybe<String>;
  link_to_poll?: Maybe<String>;
}

export interface UserVoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserVoteWhereInput>;
  AND?: Maybe<
    UserVoteSubscriptionWhereInput[] | UserVoteSubscriptionWhereInput
  >;
  OR?: Maybe<UserVoteSubscriptionWhereInput[] | UserVoteSubscriptionWhereInput>;
  NOT?: Maybe<
    UserVoteSubscriptionWhereInput[] | UserVoteSubscriptionWhereInput
  >;
}

export interface PollUpdateInput {
  userId?: Maybe<String>;
  candidateId?: Maybe<String>;
  poll_type?: Maybe<PollType>;
  error_margin?: Maybe<String>;
  link_to_poll?: Maybe<String>;
}

export interface QualificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  summary?: Maybe<String>;
  summary_not?: Maybe<String>;
  summary_in?: Maybe<String[] | String>;
  summary_not_in?: Maybe<String[] | String>;
  summary_lt?: Maybe<String>;
  summary_lte?: Maybe<String>;
  summary_gt?: Maybe<String>;
  summary_gte?: Maybe<String>;
  summary_contains?: Maybe<String>;
  summary_not_contains?: Maybe<String>;
  summary_starts_with?: Maybe<String>;
  summary_not_starts_with?: Maybe<String>;
  summary_ends_with?: Maybe<String>;
  summary_not_ends_with?: Maybe<String>;
  detail?: Maybe<String>;
  detail_not?: Maybe<String>;
  detail_in?: Maybe<String[] | String>;
  detail_not_in?: Maybe<String[] | String>;
  detail_lt?: Maybe<String>;
  detail_lte?: Maybe<String>;
  detail_gt?: Maybe<String>;
  detail_gte?: Maybe<String>;
  detail_contains?: Maybe<String>;
  detail_not_contains?: Maybe<String>;
  detail_starts_with?: Maybe<String>;
  detail_not_starts_with?: Maybe<String>;
  detail_ends_with?: Maybe<String>;
  detail_not_ends_with?: Maybe<String>;
  years?: Maybe<Int>;
  years_not?: Maybe<Int>;
  years_in?: Maybe<Int[] | Int>;
  years_not_in?: Maybe<Int[] | Int>;
  years_lt?: Maybe<Int>;
  years_lte?: Maybe<Int>;
  years_gt?: Maybe<Int>;
  years_gte?: Maybe<Int>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  candidateId?: Maybe<String>;
  candidateId_not?: Maybe<String>;
  candidateId_in?: Maybe<String[] | String>;
  candidateId_not_in?: Maybe<String[] | String>;
  candidateId_lt?: Maybe<String>;
  candidateId_lte?: Maybe<String>;
  candidateId_gt?: Maybe<String>;
  candidateId_gte?: Maybe<String>;
  candidateId_contains?: Maybe<String>;
  candidateId_not_contains?: Maybe<String>;
  candidateId_starts_with?: Maybe<String>;
  candidateId_not_starts_with?: Maybe<String>;
  candidateId_ends_with?: Maybe<String>;
  candidateId_not_ends_with?: Maybe<String>;
  like_type?: Maybe<LikeType>;
  like_type_not?: Maybe<LikeType>;
  like_type_in?: Maybe<LikeType[] | LikeType>;
  like_type_not_in?: Maybe<LikeType[] | LikeType>;
  AND?: Maybe<QualificationWhereInput[] | QualificationWhereInput>;
  OR?: Maybe<QualificationWhereInput[] | QualificationWhereInput>;
  NOT?: Maybe<QualificationWhereInput[] | QualificationWhereInput>;
}

export type UserPositionLikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TopicUpdateManyMutationInput {
  name?: Maybe<String>;
  category?: Maybe<CategoryType>;
}

export interface PollCreateInput {
  id?: Maybe<ID_Input>;
  userId: String;
  candidateId: String;
  poll_type?: Maybe<PollType>;
  error_margin?: Maybe<String>;
  link_to_poll?: Maybe<String>;
}

export interface TopicCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  category?: Maybe<CategoryType>;
}

export interface UserPositionLikeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  candidateId?: Maybe<String>;
  candidateId_not?: Maybe<String>;
  candidateId_in?: Maybe<String[] | String>;
  candidateId_not_in?: Maybe<String[] | String>;
  candidateId_lt?: Maybe<String>;
  candidateId_lte?: Maybe<String>;
  candidateId_gt?: Maybe<String>;
  candidateId_gte?: Maybe<String>;
  candidateId_contains?: Maybe<String>;
  candidateId_not_contains?: Maybe<String>;
  candidateId_starts_with?: Maybe<String>;
  candidateId_not_starts_with?: Maybe<String>;
  candidateId_ends_with?: Maybe<String>;
  candidateId_not_ends_with?: Maybe<String>;
  positionId?: Maybe<String>;
  positionId_not?: Maybe<String>;
  positionId_in?: Maybe<String[] | String>;
  positionId_not_in?: Maybe<String[] | String>;
  positionId_lt?: Maybe<String>;
  positionId_lte?: Maybe<String>;
  positionId_gt?: Maybe<String>;
  positionId_gte?: Maybe<String>;
  positionId_contains?: Maybe<String>;
  positionId_not_contains?: Maybe<String>;
  positionId_starts_with?: Maybe<String>;
  positionId_not_starts_with?: Maybe<String>;
  positionId_ends_with?: Maybe<String>;
  positionId_not_ends_with?: Maybe<String>;
  like?: Maybe<LikeType>;
  like_not?: Maybe<LikeType>;
  like_in?: Maybe<LikeType[] | LikeType>;
  like_not_in?: Maybe<LikeType[] | LikeType>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  latest?: Maybe<Boolean>;
  latest_not?: Maybe<Boolean>;
  AND?: Maybe<UserPositionLikeWhereInput[] | UserPositionLikeWhereInput>;
  OR?: Maybe<UserPositionLikeWhereInput[] | UserPositionLikeWhereInput>;
  NOT?: Maybe<UserPositionLikeWhereInput[] | UserPositionLikeWhereInput>;
}

export interface QualificationUpdateManyMutationInput {
  name?: Maybe<String>;
  summary?: Maybe<String>;
  detail?: Maybe<String>;
  years?: Maybe<Int>;
  rank?: Maybe<Int>;
  candidateId?: Maybe<String>;
  like_type?: Maybe<LikeType>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserVoteCreateInput {
  id?: Maybe<ID_Input>;
  candidateId: String;
  userId: String;
  vote_type?: Maybe<VoteType>;
  latest?: Maybe<Boolean>;
}

export interface CandidatePositionUpdateManyMutationInput {
  positionId?: Maybe<String>;
  candidateId?: Maybe<String>;
  link?: Maybe<String>;
  rank?: Maybe<Int>;
  latest?: Maybe<Boolean>;
}

export interface PollWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  candidateId?: Maybe<String>;
  candidateId_not?: Maybe<String>;
  candidateId_in?: Maybe<String[] | String>;
  candidateId_not_in?: Maybe<String[] | String>;
  candidateId_lt?: Maybe<String>;
  candidateId_lte?: Maybe<String>;
  candidateId_gt?: Maybe<String>;
  candidateId_gte?: Maybe<String>;
  candidateId_contains?: Maybe<String>;
  candidateId_not_contains?: Maybe<String>;
  candidateId_starts_with?: Maybe<String>;
  candidateId_not_starts_with?: Maybe<String>;
  candidateId_ends_with?: Maybe<String>;
  candidateId_not_ends_with?: Maybe<String>;
  poll_type?: Maybe<PollType>;
  poll_type_not?: Maybe<PollType>;
  poll_type_in?: Maybe<PollType[] | PollType>;
  poll_type_not_in?: Maybe<PollType[] | PollType>;
  error_margin?: Maybe<String>;
  error_margin_not?: Maybe<String>;
  error_margin_in?: Maybe<String[] | String>;
  error_margin_not_in?: Maybe<String[] | String>;
  error_margin_lt?: Maybe<String>;
  error_margin_lte?: Maybe<String>;
  error_margin_gt?: Maybe<String>;
  error_margin_gte?: Maybe<String>;
  error_margin_contains?: Maybe<String>;
  error_margin_not_contains?: Maybe<String>;
  error_margin_starts_with?: Maybe<String>;
  error_margin_not_starts_with?: Maybe<String>;
  error_margin_ends_with?: Maybe<String>;
  error_margin_not_ends_with?: Maybe<String>;
  link_to_poll?: Maybe<String>;
  link_to_poll_not?: Maybe<String>;
  link_to_poll_in?: Maybe<String[] | String>;
  link_to_poll_not_in?: Maybe<String[] | String>;
  link_to_poll_lt?: Maybe<String>;
  link_to_poll_lte?: Maybe<String>;
  link_to_poll_gt?: Maybe<String>;
  link_to_poll_gte?: Maybe<String>;
  link_to_poll_contains?: Maybe<String>;
  link_to_poll_not_contains?: Maybe<String>;
  link_to_poll_starts_with?: Maybe<String>;
  link_to_poll_not_starts_with?: Maybe<String>;
  link_to_poll_ends_with?: Maybe<String>;
  link_to_poll_not_ends_with?: Maybe<String>;
  AND?: Maybe<PollWhereInput[] | PollWhereInput>;
  OR?: Maybe<PollWhereInput[] | PollWhereInput>;
  NOT?: Maybe<PollWhereInput[] | PollWhereInput>;
}

export interface CandidatePositionUpdateInput {
  positionId?: Maybe<String>;
  candidateId?: Maybe<String>;
  link?: Maybe<String>;
  rank?: Maybe<Int>;
  latest?: Maybe<Boolean>;
}

export interface UserPositionLikeUpdateManyMutationInput {
  userId?: Maybe<String>;
  candidateId?: Maybe<String>;
  positionId?: Maybe<String>;
  like?: Maybe<LikeType>;
  latest?: Maybe<Boolean>;
}

export interface CandidatePositionCreateInput {
  id?: Maybe<ID_Input>;
  positionId: String;
  candidateId: String;
  link?: Maybe<String>;
  rank?: Maybe<Int>;
  latest?: Maybe<Boolean>;
}

export interface PositionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  summary?: Maybe<String>;
  summary_not?: Maybe<String>;
  summary_in?: Maybe<String[] | String>;
  summary_not_in?: Maybe<String[] | String>;
  summary_lt?: Maybe<String>;
  summary_lte?: Maybe<String>;
  summary_gt?: Maybe<String>;
  summary_gte?: Maybe<String>;
  summary_contains?: Maybe<String>;
  summary_not_contains?: Maybe<String>;
  summary_starts_with?: Maybe<String>;
  summary_not_starts_with?: Maybe<String>;
  summary_ends_with?: Maybe<String>;
  summary_not_ends_with?: Maybe<String>;
  topicId?: Maybe<String>;
  topicId_not?: Maybe<String>;
  topicId_in?: Maybe<String[] | String>;
  topicId_not_in?: Maybe<String[] | String>;
  topicId_lt?: Maybe<String>;
  topicId_lte?: Maybe<String>;
  topicId_gt?: Maybe<String>;
  topicId_gte?: Maybe<String>;
  topicId_contains?: Maybe<String>;
  topicId_not_contains?: Maybe<String>;
  topicId_starts_with?: Maybe<String>;
  topicId_not_starts_with?: Maybe<String>;
  topicId_ends_with?: Maybe<String>;
  topicId_not_ends_with?: Maybe<String>;
  detail?: Maybe<String>;
  detail_not?: Maybe<String>;
  detail_in?: Maybe<String[] | String>;
  detail_not_in?: Maybe<String[] | String>;
  detail_lt?: Maybe<String>;
  detail_lte?: Maybe<String>;
  detail_gt?: Maybe<String>;
  detail_gte?: Maybe<String>;
  detail_contains?: Maybe<String>;
  detail_not_contains?: Maybe<String>;
  detail_starts_with?: Maybe<String>;
  detail_not_starts_with?: Maybe<String>;
  detail_ends_with?: Maybe<String>;
  detail_not_ends_with?: Maybe<String>;
  like_type?: Maybe<LikeType>;
  like_type_not?: Maybe<LikeType>;
  like_type_in?: Maybe<LikeType[] | LikeType>;
  like_type_not_in?: Maybe<LikeType[] | LikeType>;
  AND?: Maybe<PositionWhereInput[] | PositionWhereInput>;
  OR?: Maybe<PositionWhereInput[] | PositionWhereInput>;
  NOT?: Maybe<PositionWhereInput[] | PositionWhereInput>;
}

export type UserQualificationLikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  gender?: Maybe<Gender>;
  role?: Maybe<Int>;
}

export interface CandidateUpdateManyMutationInput {
  name?: Maybe<String>;
  photo?: Maybe<String>;
  party?: Maybe<String>;
  state?: Maybe<String>;
  current_office?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<Gender>;
  latest_poll?: Maybe<Float>;
  latest_odds?: Maybe<Float>;
  prevote_score?: Maybe<Float>;
  bio_summary?: Maybe<String>;
  vote_type?: Maybe<VoteType>;
}

export interface PositionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PositionWhereInput>;
  AND?: Maybe<
    PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput
  >;
  OR?: Maybe<PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput>;
  NOT?: Maybe<
    PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput
  >;
}

export interface UserQualificationLikeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  qualificationId?: Maybe<String>;
  qualificationId_not?: Maybe<String>;
  qualificationId_in?: Maybe<String[] | String>;
  qualificationId_not_in?: Maybe<String[] | String>;
  qualificationId_lt?: Maybe<String>;
  qualificationId_lte?: Maybe<String>;
  qualificationId_gt?: Maybe<String>;
  qualificationId_gte?: Maybe<String>;
  qualificationId_contains?: Maybe<String>;
  qualificationId_not_contains?: Maybe<String>;
  qualificationId_starts_with?: Maybe<String>;
  qualificationId_not_starts_with?: Maybe<String>;
  qualificationId_ends_with?: Maybe<String>;
  qualificationId_not_ends_with?: Maybe<String>;
  like?: Maybe<LikeType>;
  like_not?: Maybe<LikeType>;
  like_in?: Maybe<LikeType[] | LikeType>;
  like_not_in?: Maybe<LikeType[] | LikeType>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  latest?: Maybe<Boolean>;
  latest_not?: Maybe<Boolean>;
  AND?: Maybe<
    UserQualificationLikeWhereInput[] | UserQualificationLikeWhereInput
  >;
  OR?: Maybe<
    UserQualificationLikeWhereInput[] | UserQualificationLikeWhereInput
  >;
  NOT?: Maybe<
    UserQualificationLikeWhereInput[] | UserQualificationLikeWhereInput
  >;
}

export type TopicWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserPositionLikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserPositionLikeWhereInput>;
  AND?: Maybe<
    | UserPositionLikeSubscriptionWhereInput[]
    | UserPositionLikeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserPositionLikeSubscriptionWhereInput[]
    | UserPositionLikeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserPositionLikeSubscriptionWhereInput[]
    | UserPositionLikeSubscriptionWhereInput
  >;
}

export interface UserQualificationLikeUpdateManyMutationInput {
  userId?: Maybe<String>;
  qualificationId?: Maybe<String>;
  like?: Maybe<LikeType>;
  latest?: Maybe<Boolean>;
}

export interface CandidateUpdateInput {
  name?: Maybe<String>;
  photo?: Maybe<String>;
  party?: Maybe<String>;
  state?: Maybe<String>;
  current_office?: Maybe<String>;
  age?: Maybe<Int>;
  gender?: Maybe<Gender>;
  latest_poll?: Maybe<Float>;
  latest_odds?: Maybe<Float>;
  prevote_score?: Maybe<Float>;
  bio_summary?: Maybe<String>;
  vote_type?: Maybe<VoteType>;
}

export interface UserPositionLikeUpdateInput {
  userId?: Maybe<String>;
  candidateId?: Maybe<String>;
  positionId?: Maybe<String>;
  like?: Maybe<LikeType>;
  latest?: Maybe<Boolean>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  name: String;
  password?: Maybe<String>;
  gender?: Maybe<Gender>;
  role?: Maybe<Int>;
}

export interface UserQualificationLikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserQualificationLikeWhereInput>;
  AND?: Maybe<
    | UserQualificationLikeSubscriptionWhereInput[]
    | UserQualificationLikeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserQualificationLikeSubscriptionWhereInput[]
    | UserQualificationLikeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserQualificationLikeSubscriptionWhereInput[]
    | UserQualificationLikeSubscriptionWhereInput
  >;
}

export type UserVoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CandidateCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  photo?: Maybe<String>;
  party: String;
  state: String;
  current_office: String;
  age: Int;
  gender?: Maybe<Gender>;
  latest_poll?: Maybe<Float>;
  latest_odds?: Maybe<Float>;
  prevote_score?: Maybe<Float>;
  bio_summary?: Maybe<String>;
  vote_type?: Maybe<VoteType>;
}

export interface TopicUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<CategoryType>;
}

export interface UserPositionLikeCreateInput {
  id?: Maybe<ID_Input>;
  userId: String;
  candidateId: String;
  positionId: String;
  like?: Maybe<LikeType>;
  latest?: Maybe<Boolean>;
}

export interface UserQualificationLikeUpdateInput {
  userId?: Maybe<String>;
  qualificationId?: Maybe<String>;
  like?: Maybe<LikeType>;
  latest?: Maybe<Boolean>;
}

export interface UserVoteUpdateManyMutationInput {
  candidateId?: Maybe<String>;
  userId?: Maybe<String>;
  vote_type?: Maybe<VoteType>;
  latest?: Maybe<Boolean>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserQualificationLikeEdge {
  node: UserQualificationLike;
  cursor: String;
}

export interface UserQualificationLikeEdgePromise
  extends Promise<UserQualificationLikeEdge>,
    Fragmentable {
  node: <T = UserQualificationLikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserQualificationLikeEdgeSubscription
  extends Promise<AsyncIterator<UserQualificationLikeEdge>>,
    Fragmentable {
  node: <T = UserQualificationLikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCandidatePosition {
  count: Int;
}

export interface AggregateCandidatePositionPromise
  extends Promise<AggregateCandidatePosition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCandidatePositionSubscription
  extends Promise<AsyncIterator<AggregateCandidatePosition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserVotePreviousValues {
  id: ID_Output;
  candidateId: String;
  userId: String;
  vote_type: VoteType;
  time?: DateTimeOutput;
  latest?: Boolean;
}

export interface UserVotePreviousValuesPromise
  extends Promise<UserVotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  candidateId: () => Promise<String>;
  userId: () => Promise<String>;
  vote_type: () => Promise<VoteType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface UserVotePreviousValuesSubscription
  extends Promise<AsyncIterator<UserVotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
  vote_type: () => Promise<AsyncIterator<VoteType>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface CandidatePositionEdge {
  node: CandidatePosition;
  cursor: String;
}

export interface CandidatePositionEdgePromise
  extends Promise<CandidatePositionEdge>,
    Fragmentable {
  node: <T = CandidatePositionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CandidatePositionEdgeSubscription
  extends Promise<AsyncIterator<CandidatePositionEdge>>,
    Fragmentable {
  node: <T = CandidatePositionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserVote {
  id: ID_Output;
  candidateId: String;
  userId: String;
  vote_type: VoteType;
  time?: DateTimeOutput;
  latest?: Boolean;
}

export interface UserVotePromise extends Promise<UserVote>, Fragmentable {
  id: () => Promise<ID_Output>;
  candidateId: () => Promise<String>;
  userId: () => Promise<String>;
  vote_type: () => Promise<VoteType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface UserVoteSubscription
  extends Promise<AsyncIterator<UserVote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
  vote_type: () => Promise<AsyncIterator<VoteType>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserVoteNullablePromise
  extends Promise<UserVote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  candidateId: () => Promise<String>;
  userId: () => Promise<String>;
  vote_type: () => Promise<VoteType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface CandidatePositionConnection {
  pageInfo: PageInfo;
  edges: CandidatePositionEdge[];
}

export interface CandidatePositionConnectionPromise
  extends Promise<CandidatePositionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CandidatePositionEdge>>() => T;
  aggregate: <T = AggregateCandidatePositionPromise>() => T;
}

export interface CandidatePositionConnectionSubscription
  extends Promise<AsyncIterator<CandidatePositionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CandidatePositionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCandidatePositionSubscription>() => T;
}

export interface UserVoteEdge {
  node: UserVote;
  cursor: String;
}

export interface UserVoteEdgePromise
  extends Promise<UserVoteEdge>,
    Fragmentable {
  node: <T = UserVotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserVoteEdgeSubscription
  extends Promise<AsyncIterator<UserVoteEdge>>,
    Fragmentable {
  node: <T = UserVoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserQualificationLike {
  count: Int;
}

export interface AggregateUserQualificationLikePromise
  extends Promise<AggregateUserQualificationLike>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserQualificationLikeSubscription
  extends Promise<AsyncIterator<AggregateUserQualificationLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserQualificationLikeConnection {
  pageInfo: PageInfo;
  edges: UserQualificationLikeEdge[];
}

export interface UserQualificationLikeConnectionPromise
  extends Promise<UserQualificationLikeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserQualificationLikeEdge>>() => T;
  aggregate: <T = AggregateUserQualificationLikePromise>() => T;
}

export interface UserQualificationLikeConnectionSubscription
  extends Promise<AsyncIterator<UserQualificationLikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserQualificationLikeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserQualificationLikeSubscription>() => T;
}

export interface CandidatePosition {
  id: ID_Output;
  positionId: String;
  candidateId: String;
  time?: DateTimeOutput;
  link?: String;
  rank?: Int;
  latest?: Boolean;
}

export interface CandidatePositionPromise
  extends Promise<CandidatePosition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  positionId: () => Promise<String>;
  candidateId: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
  link: () => Promise<String>;
  rank: () => Promise<Int>;
  latest: () => Promise<Boolean>;
}

export interface CandidatePositionSubscription
  extends Promise<AsyncIterator<CandidatePosition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  positionId: () => Promise<AsyncIterator<String>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  link: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface CandidatePositionNullablePromise
  extends Promise<CandidatePosition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  positionId: () => Promise<String>;
  candidateId: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
  link: () => Promise<String>;
  rank: () => Promise<Int>;
  latest: () => Promise<Boolean>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CandidateSubscriptionPayload {
  mutation: MutationType;
  node: Candidate;
  updatedFields: String[];
  previousValues: CandidatePreviousValues;
}

export interface CandidateSubscriptionPayloadPromise
  extends Promise<CandidateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CandidatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CandidatePreviousValuesPromise>() => T;
}

export interface CandidateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CandidateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CandidateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CandidatePreviousValuesSubscription>() => T;
}

export interface AggregateUserPositionLike {
  count: Int;
}

export interface AggregateUserPositionLikePromise
  extends Promise<AggregateUserPositionLike>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserPositionLikeSubscription
  extends Promise<AsyncIterator<AggregateUserPositionLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CandidatePreviousValues {
  id: ID_Output;
  name: String;
  photo?: String;
  party: String;
  state: String;
  current_office: String;
  age: Int;
  gender?: Gender;
  latest_poll?: Float;
  latest_odds?: Float;
  prevote_score?: Float;
  bio_summary?: String;
  vote_type?: VoteType;
}

export interface CandidatePreviousValuesPromise
  extends Promise<CandidatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  photo: () => Promise<String>;
  party: () => Promise<String>;
  state: () => Promise<String>;
  current_office: () => Promise<String>;
  age: () => Promise<Int>;
  gender: () => Promise<Gender>;
  latest_poll: () => Promise<Float>;
  latest_odds: () => Promise<Float>;
  prevote_score: () => Promise<Float>;
  bio_summary: () => Promise<String>;
  vote_type: () => Promise<VoteType>;
}

export interface CandidatePreviousValuesSubscription
  extends Promise<AsyncIterator<CandidatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  photo: () => Promise<AsyncIterator<String>>;
  party: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  current_office: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  latest_poll: () => Promise<AsyncIterator<Float>>;
  latest_odds: () => Promise<AsyncIterator<Float>>;
  prevote_score: () => Promise<AsyncIterator<Float>>;
  bio_summary: () => Promise<AsyncIterator<String>>;
  vote_type: () => Promise<AsyncIterator<VoteType>>;
}

export interface UserPositionLikeConnection {
  pageInfo: PageInfo;
  edges: UserPositionLikeEdge[];
}

export interface UserPositionLikeConnectionPromise
  extends Promise<UserPositionLikeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserPositionLikeEdge>>() => T;
  aggregate: <T = AggregateUserPositionLikePromise>() => T;
}

export interface UserPositionLikeConnectionSubscription
  extends Promise<AsyncIterator<UserPositionLikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserPositionLikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserPositionLikeSubscription>() => T;
}

export interface AggregateCandidate {
  count: Int;
}

export interface AggregateCandidatePromise
  extends Promise<AggregateCandidate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCandidateSubscription
  extends Promise<AsyncIterator<AggregateCandidate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CandidatePositionSubscriptionPayload {
  mutation: MutationType;
  node: CandidatePosition;
  updatedFields: String[];
  previousValues: CandidatePositionPreviousValues;
}

export interface CandidatePositionSubscriptionPayloadPromise
  extends Promise<CandidatePositionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CandidatePositionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CandidatePositionPreviousValuesPromise>() => T;
}

export interface CandidatePositionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CandidatePositionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CandidatePositionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CandidatePositionPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CandidatePositionPreviousValues {
  id: ID_Output;
  positionId: String;
  candidateId: String;
  time?: DateTimeOutput;
  link?: String;
  rank?: Int;
  latest?: Boolean;
}

export interface CandidatePositionPreviousValuesPromise
  extends Promise<CandidatePositionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  positionId: () => Promise<String>;
  candidateId: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
  link: () => Promise<String>;
  rank: () => Promise<Int>;
  latest: () => Promise<Boolean>;
}

export interface CandidatePositionPreviousValuesSubscription
  extends Promise<AsyncIterator<CandidatePositionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  positionId: () => Promise<AsyncIterator<String>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  link: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateTopic {
  count: Int;
}

export interface AggregateTopicPromise
  extends Promise<AggregateTopic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CandidateEdge {
  node: Candidate;
  cursor: String;
}

export interface CandidateEdgePromise
  extends Promise<CandidateEdge>,
    Fragmentable {
  node: <T = CandidatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CandidateEdgeSubscription
  extends Promise<AsyncIterator<CandidateEdge>>,
    Fragmentable {
  node: <T = CandidateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TopicConnection {
  pageInfo: PageInfo;
  edges: TopicEdge[];
}

export interface TopicConnectionPromise
  extends Promise<TopicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopicEdge>>() => T;
  aggregate: <T = AggregateTopicPromise>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface PollSubscriptionPayload {
  mutation: MutationType;
  node: Poll;
  updatedFields: String[];
  previousValues: PollPreviousValues;
}

export interface PollSubscriptionPayloadPromise
  extends Promise<PollSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PollPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PollPreviousValuesPromise>() => T;
}

export interface PollSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PollSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PollSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PollPreviousValuesSubscription>() => T;
}

export interface AggregateQualification {
  count: Int;
}

export interface AggregateQualificationPromise
  extends Promise<AggregateQualification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQualificationSubscription
  extends Promise<AsyncIterator<AggregateQualification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PollPreviousValues {
  id: ID_Output;
  userId: String;
  date?: DateTimeOutput;
  candidateId: String;
  poll_type: PollType;
  error_margin?: String;
  link_to_poll?: String;
}

export interface PollPreviousValuesPromise
  extends Promise<PollPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  candidateId: () => Promise<String>;
  poll_type: () => Promise<PollType>;
  error_margin: () => Promise<String>;
  link_to_poll: () => Promise<String>;
}

export interface PollPreviousValuesSubscription
  extends Promise<AsyncIterator<PollPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  poll_type: () => Promise<AsyncIterator<PollType>>;
  error_margin: () => Promise<AsyncIterator<String>>;
  link_to_poll: () => Promise<AsyncIterator<String>>;
}

export interface QualificationConnection {
  pageInfo: PageInfo;
  edges: QualificationEdge[];
}

export interface QualificationConnectionPromise
  extends Promise<QualificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QualificationEdge>>() => T;
  aggregate: <T = AggregateQualificationPromise>() => T;
}

export interface QualificationConnectionSubscription
  extends Promise<AsyncIterator<QualificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QualificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQualificationSubscription>() => T;
}

export interface Topic {
  id: ID_Output;
  name: String;
  category: CategoryType;
}

export interface TopicPromise extends Promise<Topic>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<CategoryType>;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<Topic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<CategoryType>>;
}

export interface TopicNullablePromise
  extends Promise<Topic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<CategoryType>;
}

export interface UserPositionLikePreviousValues {
  id: ID_Output;
  userId: String;
  candidateId: String;
  positionId: String;
  like?: LikeType;
  time?: DateTimeOutput;
  latest?: Boolean;
}

export interface UserPositionLikePreviousValuesPromise
  extends Promise<UserPositionLikePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  candidateId: () => Promise<String>;
  positionId: () => Promise<String>;
  like: () => Promise<LikeType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface UserPositionLikePreviousValuesSubscription
  extends Promise<AsyncIterator<UserPositionLikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<String>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  positionId: () => Promise<AsyncIterator<String>>;
  like: () => Promise<AsyncIterator<LikeType>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface QualificationEdge {
  node: Qualification;
  cursor: String;
}

export interface QualificationEdgePromise
  extends Promise<QualificationEdge>,
    Fragmentable {
  node: <T = QualificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QualificationEdgeSubscription
  extends Promise<AsyncIterator<QualificationEdge>>,
    Fragmentable {
  node: <T = QualificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePosition {
  count: Int;
}

export interface AggregatePositionPromise
  extends Promise<AggregatePosition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePositionSubscription
  extends Promise<AsyncIterator<AggregatePosition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Qualification {
  id: ID_Output;
  name: String;
  summary?: String;
  detail?: String;
  years: Int;
  rank?: Int;
  candidateId?: String;
  like_type?: LikeType;
}

export interface QualificationPromise
  extends Promise<Qualification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  summary: () => Promise<String>;
  detail: () => Promise<String>;
  years: () => Promise<Int>;
  rank: () => Promise<Int>;
  candidateId: () => Promise<String>;
  like_type: () => Promise<LikeType>;
}

export interface QualificationSubscription
  extends Promise<AsyncIterator<Qualification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  detail: () => Promise<AsyncIterator<String>>;
  years: () => Promise<AsyncIterator<Int>>;
  rank: () => Promise<AsyncIterator<Int>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  like_type: () => Promise<AsyncIterator<LikeType>>;
}

export interface QualificationNullablePromise
  extends Promise<Qualification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  summary: () => Promise<String>;
  detail: () => Promise<String>;
  years: () => Promise<Int>;
  rank: () => Promise<Int>;
  candidateId: () => Promise<String>;
  like_type: () => Promise<LikeType>;
}

export interface Position {
  id: ID_Output;
  name: String;
  summary?: String;
  topicId?: String;
  detail?: String;
  like_type?: LikeType;
}

export interface PositionPromise extends Promise<Position>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  summary: () => Promise<String>;
  topicId: () => Promise<String>;
  detail: () => Promise<String>;
  like_type: () => Promise<LikeType>;
}

export interface PositionSubscription
  extends Promise<AsyncIterator<Position>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  topicId: () => Promise<AsyncIterator<String>>;
  detail: () => Promise<AsyncIterator<String>>;
  like_type: () => Promise<AsyncIterator<LikeType>>;
}

export interface PositionNullablePromise
  extends Promise<Position | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  summary: () => Promise<String>;
  topicId: () => Promise<String>;
  detail: () => Promise<String>;
  like_type: () => Promise<LikeType>;
}

export interface PositionEdge {
  node: Position;
  cursor: String;
}

export interface PositionEdgePromise
  extends Promise<PositionEdge>,
    Fragmentable {
  node: <T = PositionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PositionEdgeSubscription
  extends Promise<AsyncIterator<PositionEdge>>,
    Fragmentable {
  node: <T = PositionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PollEdge {
  node: Poll;
  cursor: String;
}

export interface PollEdgePromise extends Promise<PollEdge>, Fragmentable {
  node: <T = PollPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PollEdgeSubscription
  extends Promise<AsyncIterator<PollEdge>>,
    Fragmentable {
  node: <T = PollSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PositionSubscriptionPayload {
  mutation: MutationType;
  node: Position;
  updatedFields: String[];
  previousValues: PositionPreviousValues;
}

export interface PositionSubscriptionPayloadPromise
  extends Promise<PositionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PositionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PositionPreviousValuesPromise>() => T;
}

export interface PositionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PositionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PositionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PositionPreviousValuesSubscription>() => T;
}

export interface Poll {
  id: ID_Output;
  userId: String;
  date?: DateTimeOutput;
  candidateId: String;
  poll_type: PollType;
  error_margin?: String;
  link_to_poll?: String;
}

export interface PollPromise extends Promise<Poll>, Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  candidateId: () => Promise<String>;
  poll_type: () => Promise<PollType>;
  error_margin: () => Promise<String>;
  link_to_poll: () => Promise<String>;
}

export interface PollSubscription
  extends Promise<AsyncIterator<Poll>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  poll_type: () => Promise<AsyncIterator<PollType>>;
  error_margin: () => Promise<AsyncIterator<String>>;
  link_to_poll: () => Promise<AsyncIterator<String>>;
}

export interface PollNullablePromise
  extends Promise<Poll | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  candidateId: () => Promise<String>;
  poll_type: () => Promise<PollType>;
  error_margin: () => Promise<String>;
  link_to_poll: () => Promise<String>;
}

export interface PositionPreviousValues {
  id: ID_Output;
  name: String;
  summary?: String;
  topicId?: String;
  detail?: String;
  like_type?: LikeType;
}

export interface PositionPreviousValuesPromise
  extends Promise<PositionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  summary: () => Promise<String>;
  topicId: () => Promise<String>;
  detail: () => Promise<String>;
  like_type: () => Promise<LikeType>;
}

export interface PositionPreviousValuesSubscription
  extends Promise<AsyncIterator<PositionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  topicId: () => Promise<AsyncIterator<String>>;
  detail: () => Promise<AsyncIterator<String>>;
  like_type: () => Promise<AsyncIterator<LikeType>>;
}

export interface AggregateUserVote {
  count: Int;
}

export interface AggregateUserVotePromise
  extends Promise<AggregateUserVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserVoteSubscription
  extends Promise<AsyncIterator<AggregateUserVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserQualificationLike {
  id: ID_Output;
  userId: String;
  qualificationId: String;
  like: LikeType;
  time?: DateTimeOutput;
  latest?: Boolean;
}

export interface UserQualificationLikePromise
  extends Promise<UserQualificationLike>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  qualificationId: () => Promise<String>;
  like: () => Promise<LikeType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface UserQualificationLikeSubscription
  extends Promise<AsyncIterator<UserQualificationLike>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<String>>;
  qualificationId: () => Promise<AsyncIterator<String>>;
  like: () => Promise<AsyncIterator<LikeType>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserQualificationLikeNullablePromise
  extends Promise<UserQualificationLike | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  qualificationId: () => Promise<String>;
  like: () => Promise<LikeType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface QualificationSubscriptionPayload {
  mutation: MutationType;
  node: Qualification;
  updatedFields: String[];
  previousValues: QualificationPreviousValues;
}

export interface QualificationSubscriptionPayloadPromise
  extends Promise<QualificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QualificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QualificationPreviousValuesPromise>() => T;
}

export interface QualificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QualificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QualificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QualificationPreviousValuesSubscription>() => T;
}

export interface UserPositionLikeEdge {
  node: UserPositionLike;
  cursor: String;
}

export interface UserPositionLikeEdgePromise
  extends Promise<UserPositionLikeEdge>,
    Fragmentable {
  node: <T = UserPositionLikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserPositionLikeEdgeSubscription
  extends Promise<AsyncIterator<UserPositionLikeEdge>>,
    Fragmentable {
  node: <T = UserPositionLikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface QualificationPreviousValues {
  id: ID_Output;
  name: String;
  summary?: String;
  detail?: String;
  years: Int;
  rank?: Int;
  candidateId?: String;
  like_type?: LikeType;
}

export interface QualificationPreviousValuesPromise
  extends Promise<QualificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  summary: () => Promise<String>;
  detail: () => Promise<String>;
  years: () => Promise<Int>;
  rank: () => Promise<Int>;
  candidateId: () => Promise<String>;
  like_type: () => Promise<LikeType>;
}

export interface QualificationPreviousValuesSubscription
  extends Promise<AsyncIterator<QualificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  detail: () => Promise<AsyncIterator<String>>;
  years: () => Promise<AsyncIterator<Int>>;
  rank: () => Promise<AsyncIterator<Int>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  like_type: () => Promise<AsyncIterator<LikeType>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CandidateConnection {
  pageInfo: PageInfo;
  edges: CandidateEdge[];
}

export interface CandidateConnectionPromise
  extends Promise<CandidateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CandidateEdge>>() => T;
  aggregate: <T = AggregateCandidatePromise>() => T;
}

export interface CandidateConnectionSubscription
  extends Promise<AsyncIterator<CandidateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CandidateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCandidateSubscription>() => T;
}

export interface TopicEdge {
  node: Topic;
  cursor: String;
}

export interface TopicEdgePromise extends Promise<TopicEdge>, Fragmentable {
  node: <T = TopicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdge>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TopicSubscriptionPayload {
  mutation: MutationType;
  node: Topic;
  updatedFields: String[];
  previousValues: TopicPreviousValues;
}

export interface TopicSubscriptionPayloadPromise
  extends Promise<TopicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValuesPromise>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface AggregatePoll {
  count: Int;
}

export interface AggregatePollPromise
  extends Promise<AggregatePoll>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePollSubscription
  extends Promise<AsyncIterator<AggregatePoll>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopicPreviousValues {
  id: ID_Output;
  name: String;
  category: CategoryType;
}

export interface TopicPreviousValuesPromise
  extends Promise<TopicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<CategoryType>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<CategoryType>>;
}

export interface UserVoteConnection {
  pageInfo: PageInfo;
  edges: UserVoteEdge[];
}

export interface UserVoteConnectionPromise
  extends Promise<UserVoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserVoteEdge>>() => T;
  aggregate: <T = AggregateUserVotePromise>() => T;
}

export interface UserVoteConnectionSubscription
  extends Promise<AsyncIterator<UserVoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserVoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserVoteSubscription>() => T;
}

export interface UserQualificationLikePreviousValues {
  id: ID_Output;
  userId: String;
  qualificationId: String;
  like: LikeType;
  time?: DateTimeOutput;
  latest?: Boolean;
}

export interface UserQualificationLikePreviousValuesPromise
  extends Promise<UserQualificationLikePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  qualificationId: () => Promise<String>;
  like: () => Promise<LikeType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface UserQualificationLikePreviousValuesSubscription
  extends Promise<AsyncIterator<UserQualificationLikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<String>>;
  qualificationId: () => Promise<AsyncIterator<String>>;
  like: () => Promise<AsyncIterator<LikeType>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface Candidate {
  id: ID_Output;
  name: String;
  photo?: String;
  party: String;
  state: String;
  current_office: String;
  age: Int;
  gender?: Gender;
  latest_poll?: Float;
  latest_odds?: Float;
  prevote_score?: Float;
  bio_summary?: String;
  vote_type?: VoteType;
}

export interface CandidatePromise extends Promise<Candidate>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  photo: () => Promise<String>;
  party: () => Promise<String>;
  state: () => Promise<String>;
  current_office: () => Promise<String>;
  age: () => Promise<Int>;
  gender: () => Promise<Gender>;
  latest_poll: () => Promise<Float>;
  latest_odds: () => Promise<Float>;
  prevote_score: () => Promise<Float>;
  bio_summary: () => Promise<String>;
  vote_type: () => Promise<VoteType>;
}

export interface CandidateSubscription
  extends Promise<AsyncIterator<Candidate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  photo: () => Promise<AsyncIterator<String>>;
  party: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  current_office: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  latest_poll: () => Promise<AsyncIterator<Float>>;
  latest_odds: () => Promise<AsyncIterator<Float>>;
  prevote_score: () => Promise<AsyncIterator<Float>>;
  bio_summary: () => Promise<AsyncIterator<String>>;
  vote_type: () => Promise<AsyncIterator<VoteType>>;
}

export interface CandidateNullablePromise
  extends Promise<Candidate | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  photo: () => Promise<String>;
  party: () => Promise<String>;
  state: () => Promise<String>;
  current_office: () => Promise<String>;
  age: () => Promise<Int>;
  gender: () => Promise<Gender>;
  latest_poll: () => Promise<Float>;
  latest_odds: () => Promise<Float>;
  prevote_score: () => Promise<Float>;
  bio_summary: () => Promise<String>;
  vote_type: () => Promise<VoteType>;
}

export interface User {
  id: ID_Output;
  email: String;
  name: String;
  password?: String;
  gender?: Gender;
  role?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  gender: () => Promise<Gender>;
  role: () => Promise<Int>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  role: () => Promise<AsyncIterator<Int>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  gender: () => Promise<Gender>;
  role: () => Promise<Int>;
}

export interface UserPositionLikeSubscriptionPayload {
  mutation: MutationType;
  node: UserPositionLike;
  updatedFields: String[];
  previousValues: UserPositionLikePreviousValues;
}

export interface UserPositionLikeSubscriptionPayloadPromise
  extends Promise<UserPositionLikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPositionLikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPositionLikePreviousValuesPromise>() => T;
}

export interface UserPositionLikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserPositionLikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserPositionLikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPositionLikePreviousValuesSubscription>() => T;
}

export interface UserQualificationLikeSubscriptionPayload {
  mutation: MutationType;
  node: UserQualificationLike;
  updatedFields: String[];
  previousValues: UserQualificationLikePreviousValues;
}

export interface UserQualificationLikeSubscriptionPayloadPromise
  extends Promise<UserQualificationLikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserQualificationLikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserQualificationLikePreviousValuesPromise>() => T;
}

export interface UserQualificationLikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserQualificationLikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserQualificationLikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserQualificationLikePreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  name: String;
  password?: String;
  gender?: Gender;
  role?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  gender: () => Promise<Gender>;
  role: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  role: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PositionConnection {
  pageInfo: PageInfo;
  edges: PositionEdge[];
}

export interface PositionConnectionPromise
  extends Promise<PositionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PositionEdge>>() => T;
  aggregate: <T = AggregatePositionPromise>() => T;
}

export interface PositionConnectionSubscription
  extends Promise<AsyncIterator<PositionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PositionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePositionSubscription>() => T;
}

export interface UserPositionLike {
  id: ID_Output;
  userId: String;
  candidateId: String;
  positionId: String;
  like?: LikeType;
  time?: DateTimeOutput;
  latest?: Boolean;
}

export interface UserPositionLikePromise
  extends Promise<UserPositionLike>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  candidateId: () => Promise<String>;
  positionId: () => Promise<String>;
  like: () => Promise<LikeType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface UserPositionLikeSubscription
  extends Promise<AsyncIterator<UserPositionLike>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<String>>;
  candidateId: () => Promise<AsyncIterator<String>>;
  positionId: () => Promise<AsyncIterator<String>>;
  like: () => Promise<AsyncIterator<LikeType>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  latest: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserPositionLikeNullablePromise
  extends Promise<UserPositionLike | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<String>;
  candidateId: () => Promise<String>;
  positionId: () => Promise<String>;
  like: () => Promise<LikeType>;
  time: () => Promise<DateTimeOutput>;
  latest: () => Promise<Boolean>;
}

export interface UserVoteSubscriptionPayload {
  mutation: MutationType;
  node: UserVote;
  updatedFields: String[];
  previousValues: UserVotePreviousValues;
}

export interface UserVoteSubscriptionPayloadPromise
  extends Promise<UserVoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserVotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserVotePreviousValuesPromise>() => T;
}

export interface UserVoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserVoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserVoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserVotePreviousValuesSubscription>() => T;
}

export interface PollConnection {
  pageInfo: PageInfo;
  edges: PollEdge[];
}

export interface PollConnectionPromise
  extends Promise<PollConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PollEdge>>() => T;
  aggregate: <T = AggregatePollPromise>() => T;
}

export interface PollConnectionSubscription
  extends Promise<AsyncIterator<PollConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PollEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePollSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Candidate",
    embedded: false
  },
  {
    name: "Qualification",
    embedded: false
  },
  {
    name: "Topic",
    embedded: false
  },
  {
    name: "Position",
    embedded: false
  },
  {
    name: "CandidatePosition",
    embedded: false
  },
  {
    name: "UserVote",
    embedded: false
  },
  {
    name: "UserQualificationLike",
    embedded: false
  },
  {
    name: "UserPositionLike",
    embedded: false
  },
  {
    name: "Poll",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "CategoryType",
    embedded: false
  },
  {
    name: "VoteType",
    embedded: false
  },
  {
    name: "LikeType",
    embedded: false
  },
  {
    name: "PollType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
